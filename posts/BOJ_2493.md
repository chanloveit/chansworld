---
id: 2
title: "[백준 2493 - 탑]"
created_at: "2026-02-22"
category: "PS"
featured: false
---
# [[백준 2493 - 탑]](https://www.acmicpc.net/problem/2493)
![백준 2493 - 탑](/images/Boj2493.jpg)
 
## 문제 이해  
각 탑은 왼쪽으로 신호를 전송한다. 신호는 자신보다 높거나 같은 탑에 가로막히며, 해당 탑의 번호를 출력한다. 가로막히지 않으면 0을 출력한다.

## 핵심 아이디어
브루트 포스로 풀면 O(N²), N <= 500000이므로 1.5초로는 부족하다.  
단조 스택을 이용하여 O(N)에 통과할 수 있다.  
스택에 입력받은 v[i], i를 std::pair로 같이 집어넣어 출력에서 요구하는 인덱스를 저장하자.  

## 소스코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
using namespace std;

int main(void) {
  cin.tie(nullptr);
  ios_base::sync_with_stdio(false);

  int n;
	cin >> n;
	vector<int> v(n);
	for(int i = 0; i < n; i++){
		cin >> v[i];
	}

	stack<pair<int, int>> s;
	s.push({v[0], 0});
	cout << 0 << ' ';
	for(int i = 1; i < n; i++){
		while(!s.empty() && s.top().first < v[i]){
			s.pop();
		}
		if(s.empty()){
			cout << 0 << ' ';
		}
		else{
			cout << s.top().second + 1 << ' ';
		}

		s.push({v[i], i});
	}
  return 0;
}
```
## 풀이
v[0]은 왼쪽에 탑이 없으므로 0을 출력하고 스택에 push한다.  
i = 1부터 n - 1까지, 스택의 top이 v[i]보다 작다면 어차피 신호를 가로막을 수 없으므로 pop한다. 이를 반복해 v[i]보다 크거나 같은 값이 top에 올 때까지 정리한다.  
정리 후 스택이 비었다면 신호를 받을 탑이 없으므로 0, 비지 않았다면 top의 인덱스를 출력한다.