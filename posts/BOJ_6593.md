---
id: 3
title: "[백준 6593 - 상범 빌딩]"
created_at: "2026-02-25"
category: "PS"
featured: false
---
# [[백준 6593 - 상범 빌딩]](https://www.acmicpc.net/problem/6593)
![백준 6593 - 상범 빌딩](/images/BOJ_6593/Boj6593.jpg)

## 문제 이해  
3차원 공간에서 S에서 E까지의 최단 경로를 구하는 문제다. 이동은 동서남북 + 상하, 총 6방향이며 벽('#')은 통과할 수 없다. 탈출이 불가능한 경우도 존재한다.

## 핵심 아이디어
2차원 BFS 풀이에서 축 하나만 추가하면 된다. `dx`, `dy` 배열에 층 이동을 위한 `dz` 배열을 추가하고, visited 배열을 3차원으로 확장한다.  
입력이 여러 테스트케이스로 주어지므로 `l`, `r`, `c`가 모두 0일 때까지 반복한다.

## 소스코드
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;

int dx[] = {-1, 1, 0, 0, 0, 0};
int dy[] = {0, 0, -1, 1, 0, 0};
int dz[] = {0, 0, 0, 0, 1, -1};

struct node{
	int x, y, z, d;
};

int main(void){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

	int l, r, c;
	cin >> l >> r >> c;
	while(l && r && c){
		bool flag = false;
		vector<vector<string>> v(l, vector<string>(r));
		vector<vector<vector<bool>>> visited(l, vector<vector<bool>>(r, vector<bool>(c, false)));
		queue<node> q;
	
		for(int i = 0; i < l; i++){
			for(int j = 0; j < r; j++){
				cin >> v[i][j];
				for(int k = 0; k < c; k++){
					if(v[i][j][k] == 'S'){
						q.push({j, k, i, 0});
						visited[i][j][k] = true;
					}
				}
			}
		}
	
		while(!q.empty()){
			int x = q.front().x;
			int y = q.front().y;
			int z = q.front().z;
			int d = q.front().d;
			q.pop();
	
			if(v[z][x][y] == 'E'){
				cout << "Escaped in " << d << " minute(s).\n";
				flag = true;
				break;
			}
	
			for(int i = 0; i < 6; i++){
				int nx = x + dx[i];
				int ny = y + dy[i];
				int nz = z + dz[i];
	
				if(nx >= r || nx < 0 || ny >= c || ny < 0 || nz >= l || nz < 0 || visited[nz][nx][ny] || v[nz][nx][ny] == '#'){
					continue;
				}
	
				visited[nz][nx][ny] = true;
				q.push({nx, ny, nz, d + 1});
			}
		}
		
		if(!flag){
			cout << "Trapped!\n";
		}
		cin >> l >> r >> c;
	}

    return 0;
}

```
## 풀이
일반적인 격자 그래프의 BFS를 통한 최단 거리의 풀이와 같다.  
입력 시 `S`를 발견하면 큐에 `{x, y, z, 0}`을 넣고 visited 표시를 한다.  
큐에서 꺼낸 노드가 `E`라면 해당 거리를 출력하고 종료한다.  
6방향으로 이동 시 범위를 벗어나거나, 이미 방문했거나, 벽인 경우는 스킵한다.  
큐가 빌 때까지 `E`에 도달하지 못하면 `Trapped!`를 출력한다.