---
id: 10
title: "[BOJ/백준 16202 - MST 게임]"
created_at: "2026-01-26"
category: "PS"
auto_head_image: "/media/10.jpg"
featured: false
---

![백준 16202](/media/10.jpg)

MST에서 제일 짧은 간선을 제거해 가면서 MST를 찾는 문제.   
k번 루프를 돌리면서 MST랑 Union-Find를 초기화하고, 간선 집합의 첫 번째 간선을 지우면서 Kruskal(또는 Prim)을 수행하면 되는 문제.  

Kruskal's Algorithm에 대해 잠깐 설명하자면, 정점의 집합을 weigth의 오름차순으로 정렬하고 집합에 추가해 가는 일종의 Greedy알고리즘이다.  
당장 제일 저렴한 간선을 선택하고, 이미 간선을 이루는 정점이 집합에 포함되어 있으면 건너뛴다. <- 간편하지 않은가?  

__전체 소스코드__

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

vector<int> parent;

int find(int x){
	if(parent[x] == x){
		return x;
	}

	else{
		return find(parent[x]);
	}
}

void merge(int x, int y){
	x = find(x);
	y = find(y);
	parent[y] = x;
}

struct edge{
	int w, s, e;
};

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	
	int n, m, k;
	cin >> n >> m >> k;

	parent.resize(n + 1, -1);
	
	vector<edge> e(m);
	for(int i = 0; i < m; i++){
		int x, y;
		cin >> x >> y;
		e[i] = {i + 1, x, y};
	}

	for(int t = 0; t < k; t++){
		for(int i = 1; i <= n; i++){
			parent[i] = i;
		}
		
		int res = 0;
		int count = 0;
		
		for(int i = 0; i < m; i++){
			int x = e[i].s;
			int y = e[i].e;

			if(find(x) != find(y)){
				merge(x, y);
				res += e[i].w;
				count++;
			}
		}

		if(count != n - 1){
			res = 0;
		}
		
		cout << res << ' ';
		e.erase(e.begin());
	}
	return 0;
}

```
