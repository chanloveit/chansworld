---
id: 9
title: "[BOJ/백준 14786 - Ax+Bsin(x)=C②]"
created_at: "2026-01-23"
auto_head_image: "/media/9.jpg"
featured: false
---

![](/media/9.jpg)

고등학교 때 배운 근사값 찾기를 컴퓨터로 구현해보자.  

A, B, C가 주어지고 Ax + Bsin(x) = C를 만족하는 x를 찾으란다.  
일단 x에 대하여 식을 정리해보자.  
Ax + Bsin(x) = C  
-> Ax = C - Bsin(x)  
-> x = (C / A) - (Bsin(x) / A)  
로 정리할 수 있다.  

A, B, C는 모두 자연수이므로 x의 범위는 0 < x < (C / A) + (B / A)로 정리할 수 있다.  
(sin(x)는 -1이상 1이하임을 기억하자.)

이분 탐색을 이용하여 x를 찾는다.  
```cpp
double left = 0;
	double right = (double)c / a + (double)b / a;
	for(int i = 0; i < 10000; i++){
		double mid = (left + right) / 2.0d;
		if(f(mid) < c){
			left = mid;
		}

		else{
			right = mid;
		}
	}
```

(f는 Ax + Bsin(x)이다.)  
f(x)는 거의 선형이라고 할 수 있으므로, 이분 탐색으로 x의 근사값을 찾는 것은 무리가 없다.  
반복문을 더 크게 할수록 더 정확한 값이 나올 테지만 100번 정도만 돌려도 정답을 받을 수 있더라.   


__전체 소스코드__
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <iomanip>
using namespace std;

int a, b, c;

double f(double x){
	return a * x + b * sin(x);
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	
	cin >> a >> b >> c;

	double left = 0;
	double right = (double)c / a + (double)b / a;
	for(int i = 0; i < 10000; i++){
		double mid = (left + right) / 2.0d;
		if(f(mid) < c){
			left = mid;
		}

		else{
			right = mid;
		}
	}

	cout << fixed << setprecision(9) << (left + right) / 2.0 << '\n';
	return 0;
}
```

iomanip으로 꼭 소수점 아래 9번째 자리까지 출력하도록. 