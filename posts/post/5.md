---
id: 5
title: "[BOJ/백준 2733 - Brainf*ck]"
created_at: "2026-01-18"
category: "PS"
auto_head_image: "/media/5.jpg"
featured: false
---

![백준 2733](/media/5.jpg)

Brainfuck의 인터프리터를 구현해보자.  

getline으로 공백을 포함한 입력을 end가 입력될 때까지 줄 단위로 받는다.  
명령어가 아닌 문자, 주석은 모두 제거하고 실행해야 하는 명령어만 하나의 string으로 남긴다.

루프 매칭. 스택을 이용한 간단한 괄호 매칭이다.  
스택이 비었는데 ]가 나오면 에러, 탐색 후 스택이 비어있지 않으면 에러다.  
```cpp
vector<int> match(code.size(), -1);
```
이렇게 해두고 루프가 시작되는 위치를 저장해 두면 ]를 만났을 때 O(1)만에 이동할 수 있다.  

모든 준비는 끝났다. 주어진 조건대로 조건문 돌리면서 실행한다.  

### 전체 소스코드
```cpp
#include <iostream>
#include <vector>
#include <stack>
#include <string>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int TC;
    cin >> TC;
    cin.ignore();

    for(int t = 1; t <= TC; t++) {
		cout << "PROGRAM #" << t << ":\n";
        string code = "", line;
        while (true) {
            getline(cin, line);
            if (line == "end") break;

            bool comment = false;
            for (char c : line) {
                if (comment) continue;
                if (c == '%') { 
					comment = true; 
					continue;
				}
                if (c == '<' || c == '>' || c == '+' || c == '-' || c == '.' || c == '[' || c == ']') {
                    code += c;
                }
            }
        }

        vector<unsigned char> memory(32768, 0);
        int pointer = 0;
		
		bool falseLoop = false;
        stack<int> st;
        vector<int> match(code.size(), -1);
        for (int i = 0; i < code.size(); i++) {
            if (code[i] == '[') st.push(i);
            else if (code[i] == ']') {
				if(st.empty()){
					falseLoop = true;
					continue;
				}
                int open = st.top(); 
				st.pop();
                match[open] = i;
                match[i] = open;
            }
        }
		
		if(falseLoop || !st.empty()){
			cout << "COMPILE ERROR\n";
			continue;
		}
		
        for (int pc = 0; pc < code.size(); pc++) {
            switch (code[pc]) {
                case '>': pointer = (pointer + 1) % 32768; break;
                case '<': pointer = (pointer == 0 ? 32767 : pointer - 1); break;
                case '+': memory[pointer] = memory[pointer] + 1; break;
                case '-': memory[pointer] = memory[pointer] - 1; break;
                case '.': cout << memory[pointer]; break;
                case '[':
                    if (memory[pointer] == 0) pc = match[pc]; break;
                case ']':
                    if (memory[pointer] != 0) pc = match[pc]; break;
            }
        }

        cout << '\n';
    }

    return 0;
}
```

개인적으로 재미있게 푼 문제다.  
쌩 구현 문제인데 상어 시리즈처럼 골치 아프지도 않고, 컴퓨터의 동작 원리가 직관적으로 느껴진다.  
이런 걸 바탕으로 해서 본인만의 난해한 프로그래밍 언어를 만들어봐도 재밌지 않을까.