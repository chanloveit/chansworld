---
id: 6
title: "[BOJ/백준 9165 - Nested Shrubbery Boxes]"
created_at: "2026-01-19"
category: "PS"
auto_head_image: "/media/6.jpg"
featured: false
---

![](/media/6.jpg)
가끔 이렇게 푼 사람이 적은 문제를 풀면 기분이 좋더라.  
LIS(Longest Increasing Subsequence) 문제이다. 근데 이제 3차원을 곁들인.  

3차원이라고 해서 별 게 있는 게 아니라, 한 박스의 높이, 너비, 길이를 가지고 세 축이 동시에 조건을 만족하는 LIS의 길이를 찾는 것이다.  
문제를 보면, 상자를 회전시켜 더 큰 상자 안에 넣을 수 있단다.   
각 상자의 변을 sort하여 가장 짧은 변 < 중간 변 < 가장 긴 변 순으로 맞추는 과정이 필요하다.

```cpp
for(int i = 0; i < n; i++){
	char x;
	cin >> temp[0] >> x >> temp[1] >> x >> temp[2];
	sort(temp.begin(), temp.end());
	
	v[i] = {temp[0], temp[1], temp[2]};
}
```

입력을 받을 때 오름차순으로 정렬하자. 
그리고 나서 상자의 크기대로 정렬한 뒤, 세 축 모두 증가하는 LIS의 길이를 찾으면 된다.  
TC의 크기가 크지 않으므로 DP로 충분하다.  


__전체 소스코드__
```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <tuple>
using namespace std;

struct box{
	int x, y, z;	
};

bool compare(box a, box b){
	return tie(a.x, a.y, a.z) < tie(b.x, b.y, b.z);
}

int main(void){
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);

	
	int n;
	cin >> n;
	while(n != -1){
		vector<box> v(n);
		vector<int> temp(3);
		for(int i = 0; i < n; i++){
			char x;
			cin >> temp[0] >> x >> temp[1] >> x >> temp[2];
			sort(temp.begin(), temp.end());
	
			v[i] = {temp[0], temp[1], temp[2]};
		}
	
		sort(v.begin(), v.end(), compare);
	
		vector<int> dp(n, 1);
		for(int i = 1; i < n; i++){
			for(int j = 0; j < i; j++){
				if(v[i].x > v[j].x && v[i].y > v[j].y && v[i].z > v[j].z){
					dp[i] = max(dp[i], dp[j] + 1);
				}
			}
		}
	
		cout << *max_element(dp.begin(), dp.end()) << '\n';
		cin >> n;
	}
	
	return 0;
}
```

LIS를 익혀 두면 solved.ac 기준 플레티넘까지 티어 올리기가 용이하다. 어느정도 유형화 된 문제들만 나올 수밖에 없으므로.  
(개인적으로는 재밌기까지 하다!)