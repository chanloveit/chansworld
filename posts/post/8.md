---
id: 8
title: "[BOJ/백준 2146 - 다리 만들기]"
created_at: "2026-01-22"
category: "PS"
auto_head_image: "/media/8.jpg"
featured: false
---
![](/media/8.jpg)

bfs만 백만번(아님) 돌리는 문제다.

![](/media/8-1.jpg)

요렇게 생겨먹은 격자를 영역별로 라벨링 해두자. 
영역의 입력을 1로 받으니 1부터 라벨링하기에는 귀찮을 거시다.  

```cpp
int check = 2;
	for(int i = 0; i < n; i++){
		for(int j = 0; j < n; j++){
			if(v[i][j] == 1){
				bfs(v, n, {i, j}, check);
				check++;
			}
		}
	}
```

이렇게 해두고 조금 생각했다. 어떻게 영역 간 최단 거리를 구할까용...  
...  
또 bfs를 돌리자.  

위의 예시 tc로 치면, 세 영역 전체에서 동시에 bfs를 시작해서, 영역을 늘려 나간다는 개념을 적용한다.  
그리하여 가장 먼저 다른 영역의 라벨을 만난다면 최단 거리일 것.  

dist라는 배열을 만들어서 본 영역에서 얼마나 뻗어왔는지를 기록한다.  
본 영역에서 시작한 칸 → 0
인접한 바다 → 1
그 다음 바다 → 2
등등...

dist를 초기화하면서 
모든 영역의 정점을 bfs의 queue에 넣고 시작한다. 
```cpp
vector<vector<int>> dist(n, vector<int>(n, -1));
	queue<point> q;
	
	for(int i = 0; i < n; i++){
		for(int j = 0; j < n; j++){
			if(v[i][j] > 1){
				dist[i][j] = 0;
				q.push({i, j});
			}
		}
	}

```

이제 2차원 격자 bfs를 돌리면서 최단 거리를 찾아내면 끝.
```cpp
int res = INT_MAX;
	while(!q.empty()){
		point p = q.front();
		q.pop();

		int x = p.x;
		int y = p.y;

		for(int i = 0; i < 4; i++){
			int nx = x + dx[i];
			int ny = y + dy[i];

			if(nx >= 0 && nx < n && ny >= 0 && ny < n){
				if(v[nx][ny] == 0){
					v[nx][ny] = v[x][y];
					dist[nx][ny] = dist[x][y] + 1;
					q.push({nx, ny});
				}

				else if(v[nx][ny] != v[x][y]){
					res = min(res, dist[nx][ny] + dist[x][y]);
				}
			}
		}
	}
```

영역에서 뻗어 나간 바다는 영역으로 채우고, 거리는 이전 영역의 dist에 1을 더해간다.  
타 영역을 만나면, 시작한 영역에서는 이미 바다를 dist[x][y]만큼 건너왔고-  
반대쪽 영역에서도 바다를 dist[nx][ny]만큼 건너왔으므로 이를 min으로 계속 갱신하면 정답.

2차원 bfs를 하도 많이 하니까 눈 감고도 칠듯..